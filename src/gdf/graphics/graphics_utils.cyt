#
# graphics_utils.cyt - Код для создания очень быстрых функций (на уровне языка си) для работы с графикой.
#
# Этот код никак не используется ядром, пока не будет скомпилирован.
#
# Это код на Cython. Создаёт файл динамического импорта модуля после компиляции.
# Этот код нужен чтобы не использовать тяжёлый numba, который увеличивает скорость запуска и размер сборки на ~+30-35мб.
# Но при этом, код ниже даже быстрее, чем если использовать numba @njit (по крайней мере в моих тестах).
#


# Импортируем:
import numpy as np
from OpenGL import GL as gl
from libc.math cimport sin, cos, pi
from cpython.long cimport PyLong_Check


# Сверхбыстрая функция для поворота четырёх 2D вершин (для 2D прямоугольника), вокруг их общего центра:
cpdef list _rot2d_vertices_rectangle_(float x, float y, float width, float height, float angle):
    # Подготовка значений:
    cdef float center_x      = x + (width  / 2.0)
    cdef float center_y      = y + (height / 2.0)
    cdef float angle_rad     = -(angle * (pi / 180.0))
    cdef float angle_rad_sin = sin(angle_rad)
    cdef float angle_rad_cos = cos(angle_rad)

    # Предварительные смещения:
    cdef float dx1 = x - center_x
    cdef float dy1 = y - center_y
    cdef float dx2 = x + width  - center_x
    cdef float dy2 = y - center_y
    cdef float dx3 = x + width  - center_x
    cdef float dy3 = y + height - center_y
    cdef float dx4 = x - center_x
    cdef float dy4 = y + height - center_y

    # Возвращаем 4 вершины спрайта:
    return [
        dx1 * angle_rad_cos - dy1 * angle_rad_sin + center_x,
        dx1 * angle_rad_sin + dy1 * angle_rad_cos + center_y,
        dx2 * angle_rad_cos - dy2 * angle_rad_sin + center_x,
        dx2 * angle_rad_sin + dy2 * angle_rad_cos + center_y,
        dx3 * angle_rad_cos - dy3 * angle_rad_sin + center_x,
        dx3 * angle_rad_sin + dy3 * angle_rad_cos + center_y,
        dx4 * angle_rad_cos - dy4 * angle_rad_sin + center_x,
        dx4 * angle_rad_sin + dy4 * angle_rad_cos + center_y
    ]


# Функция для конвертации массива квадратов в массив треугольников:
cpdef list _convert_quads_to_triangles_(list vertices):
    cdef list new_vertices = []
    cdef int i

    for i in range(0, len(vertices), 8):
        new_vertices += [
            vertices[i+0], vertices[i+1],  # Нижний левый угол.
            vertices[i+2], vertices[i+3],  # Нижний правый угол.
            vertices[i+4], vertices[i+5],  # Верхний правый угол.
            vertices[i+4], vertices[i+5],  # Верхний правый угол.
            vertices[i+6], vertices[i+7],  # Верхный левый угол.
            vertices[i+0], vertices[i+1],  # Нижний левый угол.
        ]

    return new_vertices


# Добавление спрайта в пакет текстур для пакетной отрисовки:
cpdef _sprite_batch_2d_draw_(dict tbat, object sprite, float x, float y, float width, float height, float angle):
    cdef list vertices
    cdef int tid

    if PyLong_Check(sprite):
        tid = sprite
    else: tid = sprite.id

    # Вращаем вершины спрайта:
    if angle != 0.0:
        vertices = _rot2d_vertices_rectangle_(x, y, width, height, angle)
    else:
        vertices = [
            x        , y         ,  # Нижний левый угол.
            x + width, y         ,  # Нижний правый угол.
            x + width, y + height,  # Верхний правый угол.
            x        , y + height,  # Верхный левый угол.
        ]

    # Если текстурки нет в уникальных текстурках:
    if tid not in tbat: tbat[tid] = []

    # Добавляем новый полигон для текстуры:
    tbat[tid] += vertices


# Добавление текстуры в пакет текстур для пакетной отрисовки:
cpdef _atlas_texture_batch_2d_draw_(dict tbat, int tid, list tcrd, float x, float y, float wdth, float hgth, float ang):
    cdef list vertices

    # Вращаем вершины спрайта:
    if ang != 0.0:
        vertices = _rot2d_vertices_rectangle_(x, y, wdth, hgth, ang)
    else:
        vertices = [
            x       , y       ,  # Нижний левый угол.
            x + wdth, y       ,  # Нижний правый угол.
            x + wdth, y + hgth,  # Верхний правый угол.
            x       , y + hgth,  # Верхный левый угол.
        ]

    # Если текстурки нет в уникальных текстурках:
    if tid not in tbat: tbat[tid] = ([], [])

    tbat[tid][0] += vertices
    tbat[tid][1] += tcrd


# Отрисовка пакета 2D спрайтов:
cpdef _sprite_batch_2d_render_(dict texture_batches):
    cdef int texture
    cdef list vertices

    gl.glEnable(gl.GL_TEXTURE_2D)
    gl.glEnableClientState(gl.GL_VERTEX_ARRAY)
    gl.glEnableClientState(gl.GL_TEXTURE_COORD_ARRAY)

    # Пройдитесь по каждой текстуре и отрендерьте все квадраты с этой текстурой:
    for texture, vertices in texture_batches.items():
        gl.glBindTexture(gl.GL_TEXTURE_2D, texture)
        gl.glVertexPointer(2, gl.GL_FLOAT, 0, np.array(vertices, dtype=np.float32).data)
        gl.glTexCoordPointer(2, gl.GL_FLOAT, 0, np.tile([0, 1, 1, 1, 1, 0, 0, 0], len(vertices) // 8))
        gl.glDrawArrays(gl.GL_QUADS, 0, len(vertices) // 2)
    gl.glBindTexture(gl.GL_TEXTURE_2D, 0)

    gl.glDisableClientState(gl.GL_TEXTURE_COORD_ARRAY)
    gl.glDisableClientState(gl.GL_VERTEX_ARRAY)
    gl.glDisable(gl.GL_TEXTURE_2D)


# Отрисовка атласного пакета 2D спрайтов:
cpdef _atlas_texture_batch_2d_render_(dict texture_batches):
    cdef int texture
    cdef list vertices, texcoords

    gl.glEnable(gl.GL_TEXTURE_2D)
    gl.glEnableClientState(gl.GL_VERTEX_ARRAY)
    gl.glEnableClientState(gl.GL_TEXTURE_COORD_ARRAY)

    # Пройдитесь по каждой текстуре и отрендерьте все квадраты с этой текстурой:
    for texture, (vertices, texcoords) in texture_batches.items():
        gl.glBindTexture(gl.GL_TEXTURE_2D, texture)
        gl.glVertexPointer(2, gl.GL_FLOAT, 0, np.array(vertices, dtype=np.float32).data)
        gl.glTexCoordPointer(2, gl.GL_FLOAT, 0, np.array(texcoords))
        gl.glDrawArrays(gl.GL_QUADS, 0, len(vertices) // 2)
    gl.glBindTexture(gl.GL_TEXTURE_2D, 0)

    gl.glDisableClientState(gl.GL_TEXTURE_COORD_ARRAY)
    gl.glDisableClientState(gl.GL_VERTEX_ARRAY)
    gl.glDisable(gl.GL_TEXTURE_2D)
